using UnityEngine;
using System.Collections;
using System.Text;
using System;
using System.Collections.Generic;
using System.IO;
using UnityEditor;

namespace ElementSystem
{

    public static class ElementEditorUtils 
    {

        public static void GenerateCodeForTree(GameObject tree)
        {

            bool mainComponent = tree.GetComponent(tree.name);
            string superClassName = mainComponent.GetType().BaseType.Name;
            var sb = new StringBuilder();
            string className = "";
            var parentDesigner = tree.transform.parent.GetComponentInParent<ElementDesigner>();
            if (parentDesigner != null)
            {
                className = parentDesigner.name + "_" + tree.name;
            }
            else
            {
                className = tree.name;
            }


            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using ElementSystem;");
            sb.AppendLine();
            sb.AppendLine("// This file was auto generated by ElementSystem");
            sb.AppendLine("public partial class " + className + " : " + superClassName);
            sb.AppendLine("{");

            // 寻找所有$变量transform
            var transformToTreePathDic = new Dictionary<Transform, string>();
            FindMark(true, tree.transform, transformToTreePathDic, "");

            // 生成属性
            foreach (var kv in transformToTreePathDic)
            {
                var tranfrom = kv.Key;
                var path = kv.Value;
                var variableName = tranfrom.name;
                variableName = variableName.Trim('$');
                variableName = variableName.Trim('@');
                variableName = variableName.Replace("$", "_");
                variableName = variableName.Replace("@", "_");
                variableName = variableName.Replace(" ", "_");
                variableName = variableName.Replace("+", "_");
                variableName = variableName.Replace("-", "_");
                variableName = variableName.Replace(".", "_");
                variableName = variableName.Replace("<", "_");
                variableName = variableName.Replace(">", "_");
                variableName = variableName.Replace("[", "_");
                variableName = variableName.Replace("]", "_");
                variableName = variableName.Trim('_');
                var propertyName = ToProertyFormat(variableName);
                var backfeildName = ToBackfeildFormat(variableName);
                // 决定type
                var typeName = "";
                var compponentSerachTypeList = new Type[]
                {
                    // typeof(Element),
                    // typeof(ElementScrollView),
                    // typeof(View),
                    // typeof(UIWidget),
                    // typeof(UIRect),
                    // typeof(UIWidgetContainer),
                    //typeof(ScrollViewHelper),
                    //typeof(UIPoolList),
                    typeof(MonoBehaviour),
                };
                foreach (var type in compponentSerachTypeList)
                {
                    var com = tranfrom.GetComponent(type);
                    if (com == null)
                    {
                        continue;
                    }
                    typeName = com.GetType().Name;
                    break;
                }
          
                if (typeName == "")
                {
                    typeName = "Transform";
                }

                sb.AppendLine("\tprivate " + typeName + " " + backfeildName + ";");
                sb.AppendLine("\tprotected " + typeName + " " + propertyName);
                sb.AppendLine("\t{");
                sb.AppendLine("\t\tget");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif(" + backfeildName + " == null)");
                sb.AppendLine("\t\t\t{");
                sb.AppendLine("\t\t\t\tvar t = ElementUtils.FindByPath(transform, \"" + path + "\");");
                sb.AppendLine("\t\t\t\t" + backfeildName +" = t.GetComponent<" + typeName + ">();");
                sb.AppendLine("\t\t\t}");
                sb.AppendLine("\t\t\treturn " + backfeildName + ";");
                sb.AppendLine("\t\t}");
                sb.AppendLine("\t}");
                sb.AppendLine();
            }

            // 结束部分类
            sb.AppendLine("}");
            // 代码
            var code = sb.ToString();
            // 写文件
            var filePath = ResolveCodeFilePath(className);
            File.WriteAllText(filePath, code);
            AssetDatabase.Refresh();
            Debug.Log("[ElementSystem] code generated at: " + filePath);
        }
            

        private static void FindMark(bool isRoot, Transform t, Dictionary<Transform, string> dic, string parentPath)
        {
            if (t.name.Contains("/"))
            {
                throw new Exception("transform name can't contains '/'");
            }
            string path;
            if (isRoot)
            {
                path = "";
            }
            else
            {
                path = parentPath == "" ? t.name : parentPath + "/" + t.name;
            }
            bool rescure = true;
            if (t.name.StartsWith("$"))
            {
                dic[t] = path;
            }
            else if (t.name.StartsWith("@"))
            {
                dic[t] = path;
                rescure = false;
            }
            else if (t.name.StartsWith("."))
            {
                rescure = false;
            }

            if (!isRoot)
            {
                if (rescure)
                {
                    if (t.GetComponent<ElementDesigner>() != null || t.GetComponent<Element>() != null)
                    {
                        rescure = false;
                    }
                }
            }

            if (rescure)
            {
                for (int i = 0; i < t.childCount; i++)
                {
                    var child = t.GetChild(i);
                    FindMark(false, child, dic, path);
                }
            }

        }

        private static string ToProertyFormat(string name)
        {
            return name.Substring(0,1).ToUpper() + name.Substring(1);
        }

        private static string ToBackfeildFormat(string name)
        {
            return "_" + name.Substring(0,1).ToLower() + name.Substring(1);
        }

        public static String FindCodeFilePath(string codeFileName)
        {
            var searchStr = codeFileName + " t:script";
            var idList = AssetDatabase.FindAssets(searchStr);
            Debug.Log(searchStr);
            foreach (var id in idList)
            {
                var path = AssetDatabase.GUIDToAssetPath(id);
                Debug.Log(path);
                var fileName = Path.GetFileName(path);
                if (fileName == codeFileName + ".cs")
                {
                    return path;
                }
            }
            return null;
        }

        public static string ResolveCodeFilePath(string className)
        {
            var fileName = className + "+";
            var filePath = FindCodeFilePath(fileName);
            if (!string.IsNullOrEmpty(filePath))
            {
                return filePath;
            }
            else
            {
                var generateCodeDir = "Assets/ElementGenerateCode";
                if (!Directory.Exists(generateCodeDir))
                {
                    Directory.CreateDirectory(generateCodeDir);
                }
                var newFilePath = generateCodeDir + "/" + fileName + ".cs";
                return newFilePath;
            }
        }

    }

}