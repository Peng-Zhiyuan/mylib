using UnityEngine;using System.Collections.Generic;using System;[ExecuteInEditMode][RequireComponent(typeof(UIScrollView))][AddComponentMenu("NGUI/UI/UIScrollViewHelper")]public class UIScrollViewHelper: MonoBehaviour{	[System.NonSerialized]	public int SelectIndex;	public enum ScrollType	{		KeepCurrentOffset,		KeepCurrentLine,		SetLast,		SetFirst,		SetCenter,		MoveToFirst,		MoveToLast,		MoveToCenter,		NoOperation,	}	public Transform root;	public GameObject Node;	public bool autoSizeClip = false;	public float cellWidth = 0;	public float cellHight = 0;	private UIScrollView scrollView;	private UIPanel panel;	private UIGrid grid;	private float panelWidth = 0;	private float panelHight = 0;	private int curLine = 0;	private int totalLineCount = 0;	private int showLineCount = 0;	private int maxOffset;	private Transform sNode;	private Transform eNode;	private Transform mTransform;	private List<object> DataList = new List<object>();	private List<ScrollViewNode> cacheNodes = new List<ScrollViewNode>();	private bool autoDragging = false;	public Action onStopped;	public int maxPerLine = 1;	public bool stopWithCurrentLine = false;	public List<ScrollViewNode> Nodes {		get {			return cacheNodes;		}	}	public int MaxShowCount {		get {			return showLineCount;		}	}	public ScrollViewNode SelectNode {		get {			foreach (ScrollViewNode node in cacheNodes) {				if (node.NodeIndex == SelectIndex) {					return node;				}			}			return cacheNodes[0];		}	}	public UIScrollView ScrollView {		get {			return scrollView;		}	}     	// TODO:提出成ngui extension    	public Vector2 ViewSize {		get {			return NGUIHelper.Instance.ViewSize;		}	}	public void Awake()	{		if (Node != null)			Node.SetActive(false);		if (scrollView == null)			scrollView = GetComponent<UIScrollView>();		if (panel == null)			panel = scrollView.GetComponent<UIPanel>();		if (grid == null)			grid = root.GetComponent<UIGrid>();		mTransform = transform;		if (grid != null) {			grid.enabled = false;			cellWidth = grid.cellWidth;			cellHight = grid.cellHeight;			maxPerLine = grid.maxPerLine;			}		if (autoSizeClip) {			if (scrollView.movement == UIScrollView.Movement.Horizontal) {				panel.SetRect(100, 100, ViewSize.x, panel.GetViewSize().y);						} else {				panel.SetRect(0, 0, panel.GetViewSize().x, ViewSize.y);			}		}		panelWidth = panel.GetViewSize().x;		panelHight = panel.GetViewSize().y;		panel.clipOffset = Vector2.zero;			mTransform.localPosition = Vector3.zero;		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			showLineCount = Mathf.CeilToInt((panelWidth - panel.clipSoftness.x * 2) / cellWidth);			root.localPosition = Vector3.left * (panelWidth / 2 - panel.clipSoftness.x - cellWidth / 2);						} else {			showLineCount = Mathf.CeilToInt((panelHight - panel.clipSoftness.y * 2) / cellHight);			root.localPosition = Vector3.up * (panelHight / 2 - panel.clipSoftness.y - cellHight / 2);		}		if (cacheNodes.Count == 0) {			int i = 0;			while (i++ < (showLineCount + 2) * maxPerLine) {				GameObject go = NGUITools.AddChild(root.gameObject, Node);				ScrollViewNode node = go.GetComponent<ScrollViewNode>();				cacheNodes.Add(node);				node.viewHelper = this;				go.SetActive(false);			}			scrollView.onMomentumMove = onMomentumMove;			scrollView.onDragStarted = onDragStart;		}		if (sNode == null) {			GameObject go = new GameObject();			go.name = "sNode";			UIWidget widget = go.AddComponent<UIWidget>();			widget.SetRect(0, 0, cellWidth, cellHight);			sNode = go.transform;			sNode.parent = root;			sNode.localScale = Vector3.one;		}		if (eNode == null) {			GameObject go = new GameObject();			go.name = "eNode";			UIWidget widget = go.AddComponent<UIWidget>();			widget.SetRect(0, 0, cellWidth, cellHight);			eNode = go.transform;			eNode.parent = root;			eNode.localScale = Vector3.one;		}	}	void Update()	{		if (scrollView.isDragging || autoDragging) {			if (CurrentLine != curLine) {				curLine = CurrentLine;				RefreshView();			}				}	}	void OnDisable()	{		autoDragging = false;	}	private bool dragging = false;	private void onDragStart()	{		scrollView.onStoppedMoving = onStoppedMoving;		dragging = true;	}	private void onStoppedMoving()	{		if (onStopped != null)			onStopped();		scrollView.onStoppedMoving = null;	}	//衔接手动移动到停止	private void onMomentumMove()	{		if (dragging) {			if (stopWithCurrentLine)				MoveToLine(CurrentLine);			dragging = false;		}		if (CurrentLine != curLine) {			curLine = CurrentLine;			RefreshView();		}		autoDragging = false;	}	public void Init<T>(List<T> data)	{		Data.Clear();		for (int i = 0; i < data.Count; i++) {			Data.Add((object)data[i]);		}		Init();	}	public  List<object> Data {		get {			return DataList;		}		set {			DataList = value;		}	}	public int TotalLineCount {		get {						return Mathf.CeilToInt(Data.Count / maxPerLine);		}	}	private bool commenset = false;	public void Init(ScrollType scrollType = ScrollType.KeepCurrentOffset)	{		if (scrollView == null)			Awake();		scrollView.DisableSpring();		totalLineCount = TotalLineCount;		UIWidget swidget = sNode.GetComponent<UIWidget>();		swidget.SetRect(0, 0, cellWidth, cellHight);		UIWidget ewidget = eNode.GetComponent<UIWidget>();		ewidget.SetRect(0, 0, cellWidth, cellHight);		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			sNode.localPosition = Vector3.zero;			eNode.localPosition = Vector3.right * cellWidth * (totalLineCount - 1);			showLineCount = Mathf.CeilToInt((panelWidth - panel.clipSoftness.x * 2) / cellWidth);			maxOffset = Mathf.Max((int)(totalLineCount * cellWidth - panelWidth + 2 * panel.clipSoftness.x), 0);		} else {			sNode.localPosition = Vector3.zero;			eNode.localPosition = Vector3.down * cellHight * (totalLineCount - 1);			showLineCount = Mathf.CeilToInt((panelHight - panel.clipSoftness.y * 2) / cellHight);			maxOffset = Mathf.Max((int)(totalLineCount * cellHight - panelHight + 2 * panel.clipSoftness.y), 0);		}		if (!commenset) {			scrollView.disableDragIfFits = true;			if (scrollView.movement == UIScrollView.Movement.Horizontal) {				scrollView.contentPivot = UIWidget.Pivot.Left;				if (grid != null)					grid.pivot = UIWidget.Pivot.Left;			} else {				scrollView.contentPivot = UIWidget.Pivot.Top;				if (grid != null)					grid.pivot = UIWidget.Pivot.Top;			}			if (maxPerLine > 1 && grid != null)				grid.pivot = UIWidget.Pivot.TopLeft;			commenset = true;		}		if (Data.Count == 0) {			RefreshView(true);			return;		}		switch (scrollType) {			default:			case ScrollType.KeepCurrentOffset:				if (ScrollOffset < 0) {					ScrollOffset = 0;				} else					RefreshView(true);				break;			case ScrollType.KeepCurrentLine:				SetLine(CurrentLine);				break;			case ScrollType.SetFirst:				SetLine(0);				break;			case ScrollType.SetLast:				SetLine(totalLineCount);				break;			case ScrollType.SetCenter:				SetCenter();				break;							case ScrollType.MoveToLast:				MoveToLine(totalLineCount);				break;			case ScrollType.MoveToFirst:				MoveToLine(0);				break;			case ScrollType.MoveToCenter:				MoveToCenter();				break;			case ScrollType.NoOperation:				break;		}	}	public int NodeIndex(ScrollViewNode node)	{		return node.NodeIndex;//		if(scrollView.movement == UIScrollView.Movement.Horizontal)//		{//			int x = Mathf.FloorToInt(node.Trans.localPosition.x/cellWidth);//			int y = Mathf.FloorToInt(node.Trans.localPosition.y/cellHight);//			return 	x* maxPerLine+y;//		}//		else //if(scrollView.movement == UIScrollView.Movement.Vertical)//		{//			int x = Mathf.FloorToInt(node.Trans.localPosition.x/cellWidth);//			int y = Mathf.FloorToInt(node.Trans.localPosition.y/cellHight);//			return x+y*maxPerLine;//		}	}	public void RefreshView(bool force = false)	{		if (totalLineCount * maxPerLine <= cacheNodes.Count) {			if (force) {				int index = 0;				foreach (object tData in Data) {					cacheNodes[index].gameObject.SetActive(true);					cacheNodes[index].NodeIndex = index;					cacheNodes[index].SetInfo(DataList[index]);					SetPositionByIndex(cacheNodes[index], index);					index++;				}				while (index < cacheNodes.Count) {					cacheNodes[index].gameObject.SetActive(false);					index++;				}						}		} else {			int curIndex = CurrentIndex;			int sIndex = 0;			if (curIndex <= 0)				sIndex = 0;			else if (curIndex > Data.Count - cacheNodes.Count) {				sIndex = Data.Count - cacheNodes.Count;			} else				sIndex = curIndex - maxPerLine;			if (force) {				for (int index = sIndex; index < (sIndex + cacheNodes.Count); index++) {					int nIndex = index - sIndex;									cacheNodes[nIndex].gameObject.SetActive(true);					SetPositionByIndex(cacheNodes[nIndex], index);					cacheNodes[nIndex].NodeIndex = index;					cacheNodes[nIndex].SetInfo(DataList[index]);				}			} else {				int firstIndex = NodeIndex(cacheNodes[0]);				int lastIndex = NodeIndex(cacheNodes[cacheNodes.Count - 1]);				for (int index = sIndex; index < (sIndex + cacheNodes.Count); index++) {					int nIndex = index - sIndex;					if (index >= firstIndex && index <= lastIndex)						continue;					Debug.LogError("nindex" + nIndex);					ScrollViewNode firstNode = cacheNodes[0];					ScrollViewNode lastNode = cacheNodes[cacheNodes.Count - 1];					ScrollViewNode node = null;					if (index < firstIndex) {						cacheNodes.Remove(lastNode);						cacheNodes.Insert(nIndex, lastNode);						node = lastNode;					} else if (index > lastIndex) {						cacheNodes.Remove(firstNode);						cacheNodes.Add(firstNode);						node = firstNode;					}					node.gameObject.SetActive(true);					SetPositionByIndex(node, index);					node.NodeIndex = index;					node.SetInfo(DataList[index]);				}			}		}	}	private void SetPositionByIndex(ScrollViewNode node, int index)	{		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			int x = index / maxPerLine;			int y = index % maxPerLine;			node.transform.localPosition = Vector3.right * x * cellWidth + Vector3.down * y * cellHight;		} else {			int x = index % maxPerLine;			int y = index / maxPerLine;			node.transform.localPosition = Vector3.right * x * cellWidth + Vector3.down * y * cellHight;		}	}	public float ScrollOffset {		get {			if (scrollView.movement == UIScrollView.Movement.Horizontal) {				return panel.clipOffset.x;			} else {				return -panel.clipOffset.y;			}		}		set {			float offset = value;			Debug.Log("offset:" + offset);			scrollView.DisableSpring();			scrollView.ResetPosition();			if (scrollView.movement == UIScrollView.Movement.Horizontal) {				scrollView.MoveRelative(new Vector3(-offset, 0, 0));			} else {				scrollView.MoveRelative(new Vector3(0, offset, 0));			}			RefreshView(true);		}	}	public void SetCenter()	{		if (Data.Count == 0)			return;		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			ScrollOffset = totalLineCount * cellWidth / 2 - (panelWidth / 2 - panel.clipSoftness.x);				} else {			ScrollOffset = totalLineCount * cellHight / 2 - (panelHight / 2 - panel.clipSoftness.y);		}		}	public void SetScrollOffset(float offset, bool force = false)	{		if (!force)			offset = Mathf.Clamp(offset, 0, maxOffset);		ScrollOffset = offset;	}			public void SetLine(int line)	{		line = Mathf.Clamp(line, 0, totalLineCount - 1);		scrollView.DisableSpring();		scrollView.ResetPosition();		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			int offset = (int)(Mathf.Min(cellWidth * line, maxOffset));					scrollView.MoveRelative(new Vector3(-offset, 0, 0));		} else {			int offset = (int)(Mathf.Min(cellHight * line, maxOffset));			scrollView.MoveRelative(new Vector3(0, offset, 0));		}		RefreshView(true);	}	public int CurrentLine {		get {			if (scrollView.movement == UIScrollView.Movement.Horizontal) {                return Mathf.FloorToInt(panel.clipOffset.x / cellWidth);			} else {                return Mathf.FloorToInt(-panel.clipOffset.y / cellHight);			}		}	}	public int CurrentIndex {		get {			return CurrentLine * maxPerLine;		}	}	public void MoveToCenter(float strength = 8f)	{				RefreshView(true);		if (Data.Count == 0)			return;			if (scrollView.movement == UIScrollView.Movement.Horizontal) {			int offset = (int)(totalLineCount * cellWidth / 2 - (panelWidth / 2 - panel.clipSoftness.x));			SpringPanel.Begin(panel.gameObject, new Vector3(-offset, 0, 0), strength);		} else {			int offset = (int)(totalLineCount * cellHight / 2 - (panelHight / 2 - panel.clipSoftness.y));			SpringPanel.Begin(panel.gameObject, new Vector3(0, offset, 0), strength);//.onFinished = onMomentumMove;		}	}	public void MoveToLine(int line, float strength = 8f)	{				RefreshView(true);		if (Data.Count == 0)			return;		line = Mathf.Clamp(line, 0, totalLineCount - 1);		scrollView.DisableSpring();		autoDragging = true;		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			int offset = (int)(Mathf.Min(cellWidth * line, maxOffset));			SpringPanel.Begin(panel.gameObject, new Vector3(-offset, 0, 0), strength);		} else {			int offset = (int)(Mathf.Min(cellHight * line, maxOffset));			SpringPanel.Begin(panel.gameObject, new Vector3(0, offset, 0), strength);		}			}	public bool isFirstOne {		get {			if (CurrentLine <= 0)				return true;			return false;		}	}	public bool isLastOne {		get {			if (Data.Count == 0 || CurrentLine >= totalLineCount - showLineCount)				return true;			return false;		}	}	public bool needScroll {		get {			return totalLineCount > showLineCount;		}	}	public void MoveLeft()	{		curLine = CurrentLine;		if (curLine <= 0)			return;		curLine--;		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			SpringPanel.Begin(panel.gameObject, new Vector3(-cellWidth, 0, 0) * (curLine), 8.0f);		} else {			SpringPanel.Begin(panel.gameObject, new Vector3(0, cellHight, 0) * (curLine), 8.0f);		}		RefreshView();	}	public void MoveRight()	{		curLine = CurrentLine;		if (curLine >= totalLineCount - showLineCount)			return;		curLine++;		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			SpringPanel.Begin(panel.gameObject, new Vector3(-cellWidth, 0, 0) * (curLine), 8.0f);		} else {			SpringPanel.Begin(panel.gameObject, new Vector3(0, cellHight, 0) * (curLine), 8.0f);		}		RefreshView();	}	public void SetLeft(int step = 1)	{		scrollView.DisableSpring();		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			scrollView.MoveRelative(new Vector3(cellWidth * step, 0, 0));		} else {			scrollView.MoveRelative(new Vector3(0, -cellHight * step, 0));		}		RefreshView();	}	public void SetRight(int step = 1)	{		scrollView.DisableSpring();		if (scrollView.movement == UIScrollView.Movement.Horizontal) {			scrollView.MoveRelative(new Vector3(-cellWidth * step, 0, 0));		} else {			scrollView.MoveRelative(new Vector3(0, cellHight * step, 0));		}		RefreshView();	}}